/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";

var obsidian = require("obsidian");

const DEFAULT_SETTINGS = {
    shuffleQuestions: false,
    shuffleAnswers: false,
    showTimer: true,
    defaultTimeLimit: 0,
    showImmediateFeedback: false
};

function parseQuestions(content) {
    const questions = [];
    const questionBlocks = content.split(/(?=Q\d+\.)/);
    
    for (const block of questionBlocks) {
        const trimmed = block.trim();
        if (!trimmed || !trimmed.match(/^Q\d+\./)) continue;
        
        const question = parseQuestionBlock(trimmed);
        if (question) {
            questions.push(question);
        }
    }
    
    return questions;
}

function parseQuestionBlock(block) {
    const lines = block.split('\n').map(l => l.trim()).filter(l => l);
    
    if (lines.length === 0) return null;
    
    const firstLine = lines[0];
    const idMatch = firstLine.match(/^Q(\d+)\.\s*(.*)/);
    if (!idMatch) return null;
    
    const id = idMatch[1];
    let questionText = idMatch[2];
    
    const options = [];
    let correctAnswers = [];
    let imageUrl = undefined;
    let answerLineIndex = -1;
    
    const imagePattern = /!\[\[([^\]]+)\]\]|!\[([^\]]*)\]\(([^)]+)\)/;
    
    let questionTextLines = [questionText];
    let i = 1;
    
    while (i < lines.length) {
        const line = lines[i];
        
        const imgMatch = line.match(imagePattern);
        if (imgMatch) {
            imageUrl = imgMatch[1] || imgMatch[3];
            i++;
            continue;
        }
        
        if (line.match(/^[A-Z]\.\s+/)) {
            break;
        }
        
        if (line.match(/^Answer:/i)) {
            break;
        }
        
        const textImgMatch = line.match(imagePattern);
        if (textImgMatch) {
            imageUrl = textImgMatch[1] || textImgMatch[3];
        } else if (line.toLowerCase().includes('with image support')) {
            // Skip this meta line
        } else {
            questionTextLines.push(line);
        }
        i++;
    }
    
    questionText = questionTextLines.join(' ').trim();
    
    const textImgMatch = questionText.match(imagePattern);
    if (textImgMatch && !imageUrl) {
        imageUrl = textImgMatch[1] || textImgMatch[3];
        questionText = questionText.replace(imagePattern, '').trim();
    }
    
    while (i < lines.length) {
        const line = lines[i];
        
        if (line.match(/^Answer:/i)) {
            answerLineIndex = i;
            break;
        }
        
        const optionMatch = line.match(/^([A-Z])\.\s+(.*)/);
        if (optionMatch) {
            options.push({
                letter: optionMatch[1],
                text: optionMatch[2]
            });
        }
        
        i++;
    }
    
    if (answerLineIndex >= 0) {
        const answerLine = lines[answerLineIndex];
        const answerMatch = answerLine.match(/^Answer:\s*(.*)/i);
        if (answerMatch) {
            const answerText = answerMatch[1].trim();
            
            if (answerText.match(/^[A-Z](\s*,\s*[A-Z])*$/)) {
                correctAnswers = answerText.split(/\s*,\s*/).map(a => a.trim().toUpperCase());
            } else if (answerText.match(/^[A-Z]$/)) {
                correctAnswers = [answerText.toUpperCase()];
            } else {
                correctAnswers = [answerText];
            }
        }
    }
    
    let type;
    if (options.length === 0) {
        type = 'freetext';
    } else if (correctAnswers.length > 1 && correctAnswers.every(a => a.match(/^[A-Z]$/))) {
        type = 'multiple';
    } else {
        type = 'single';
    }
    
    return {
        id,
        text: questionText,
        imageUrl,
        options,
        correctAnswers,
        type
    };
}

function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

function formatQuestionForExport(q, includeUserAnswer = false) {
    let output = `Q${q.id}. ${q.text}\n\n`;
    
    if (q.imageUrl) {
        output += `![[${q.imageUrl}]]\n\n`;
    }
    
    q.options.forEach(opt => {
        output += `${opt.letter}. ${opt.text}\n`;
    });
    
    if (q.options.length > 0) {
        output += `\nAnswer: ${q.correctAnswers.join(', ')}\n`;
    } else {
        output += `Answer: ${q.correctAnswers[0]}\n`;
    }
    
    if (includeUserAnswer) {
        output += `\n---\n`;
        output += `> **Your Answer:** `;
        if (!q.userAnswer || (Array.isArray(q.userAnswer) && q.userAnswer.length === 0) || q.userAnswer === '') {
            output += `*(Not answered)*\n`;
        } else if (Array.isArray(q.userAnswer)) {
            output += `${q.userAnswer.join(', ')}\n`;
        } else {
            output += `${q.userAnswer}\n`;
        }
        output += `> **Correct Answer:** ${q.correctAnswers.join(', ')}\n`;
        
        if (q.options.length > 0 && q.userAnswer && (Array.isArray(q.userAnswer) ? q.userAnswer.length > 0 : true)) {
            const userAnswers = Array.isArray(q.userAnswer) ? q.userAnswer : [q.userAnswer];
            const selectedOptions = q.options.filter(opt => userAnswers.includes(opt.letter));
            if (selectedOptions.length > 0) {
                output += `> **You selected:** ${selectedOptions.map(o => `${o.letter}. ${o.text}`).join(' | ')}\n`;
            }
        }
        
        if (q.options.length > 0) {
            const correctOptions = q.options.filter(opt => q.correctAnswers.includes(opt.letter));
            if (correctOptions.length > 0) {
                output += `> **Correct option(s):** ${correctOptions.map(o => `${o.letter}. ${o.text}`).join(' | ')}\n`;
            }
        }
    }
    
    return output;
}

class ExamModal extends obsidian.Modal {
    constructor(app, questions, settings, sourcePath, sourceFileName) {
        super(app);
        this.currentIndex = 0;
        this.timerInterval = null;
        this.examContainer = null;
        this.settings = settings;
        this.sourcePath = sourcePath;
        this.sourceFileName = sourceFileName;
        
        this.questions = settings.shuffleQuestions ? shuffleArray(questions) : [...questions];
        
        if (settings.shuffleAnswers) {
            this.questions = this.questions.map(q => ({
                ...q,
                options: shuffleArray(q.options)
            }));
        }
        
        this.startTime = Date.now();
    }
    
    onOpen() {
        const { contentEl, modalEl } = this;
        
        modalEl.addClass('exam-creator-modal-container');
        
        contentEl.empty();
        contentEl.addClass('exam-creator-modal');
        
        // Header
        const header = contentEl.createDiv('exam-header');
        
        const headerLeft = header.createDiv('exam-header-left');
        const examTitle = headerLeft.createDiv('exam-title');
        examTitle.textContent = this.sourceFileName.replace(/\.md$/, '');
        
        const progressInfo = headerLeft.createDiv('exam-progress');
        progressInfo.createSpan({ text: `Question ` });
        progressInfo.createSpan({ cls: 'current-question', text: '1' });
        progressInfo.createSpan({ text: ` of ${this.questions.length}` });
        
        const headerRight = header.createDiv('exam-header-right');
        
        if (this.settings.showTimer) {
            const timerEl = headerRight.createDiv('exam-timer');
            timerEl.createSpan({ cls: 'timer-icon', text: '‚è±' });
            timerEl.createSpan({ cls: 'timer-value', text: '00:00' });
            
            this.timerInterval = window.setInterval(() => {
                const elapsed = Math.floor((Date.now() - this.startTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                const timerValue = timerEl.querySelector('.timer-value');
                if (timerValue) {
                    timerValue.textContent = `${minutes}:${seconds}`;
                }
            }, 1000);
        }
        
        // Progress bar
        const progressBar = contentEl.createDiv('exam-progress-bar');
        progressBar.createDiv('exam-progress-fill');
        
        // Main content area
        const mainContent = contentEl.createDiv('exam-main-content');
        
        // Sidebar with question navigator
        const sidebar = mainContent.createDiv('exam-sidebar');
        
        const sidebarHeader = sidebar.createDiv('sidebar-header');
        sidebarHeader.createEl('h3', { text: 'Questions' });
        
        const statusSummary = sidebar.createDiv('status-summary');
        statusSummary.createDiv({ cls: 'status-item status-answered-count' }).innerHTML = '<span class="status-dot answered"></span><span class="status-count">0</span> Answered';
        statusSummary.createDiv({ cls: 'status-item status-remaining-count' }).innerHTML = `<span class="status-dot remaining"></span><span class="status-count">${this.questions.length}</span> Remaining`;
        
        const questionGrid = sidebar.createDiv('question-grid');
        this.questions.forEach((_, idx) => {
            const gridItem = questionGrid.createDiv('grid-item');
            gridItem.textContent = (idx + 1).toString();
            gridItem.onclick = () => this.goToQuestion(idx);
        });
        this.questionGrid = questionGrid;
        
        // Question container - scrollable area
        this.examContainer = mainContent.createDiv('exam-container');
        
        // Bottom navigation
        const bottomNav = contentEl.createDiv('exam-bottom-nav');
        
        const navLeft = bottomNav.createDiv('nav-left');
        const prevBtn = navLeft.createEl('button', { cls: 'exam-btn exam-btn-secondary' });
        prevBtn.innerHTML = '<span class="btn-icon">‚Üê</span> Previous';
        prevBtn.onclick = () => this.goToPrevious();
        
        const navCenter = bottomNav.createDiv('nav-center');
        
        const jumpContainer = navCenter.createDiv('jump-container');
        jumpContainer.createSpan({ text: 'Go to question: ', cls: 'jump-label' });
        const jumpInput = jumpContainer.createEl('input', {
            type: 'number',
            cls: 'jump-input',
            attr: { min: '1', max: this.questions.length.toString(), placeholder: '#' }
        });
        jumpInput.onkeydown = (e) => {
            if (e.key === 'Enter') {
                const num = parseInt(jumpInput.value);
                if (num >= 1 && num <= this.questions.length) {
                    this.goToQuestion(num - 1);
                    jumpInput.value = '';
                }
            }
        };
        const jumpBtn = jumpContainer.createEl('button', { text: 'Go', cls: 'exam-btn exam-btn-small' });
        jumpBtn.onclick = () => {
            const num = parseInt(jumpInput.value);
            if (num >= 1 && num <= this.questions.length) {
                this.goToQuestion(num - 1);
                jumpInput.value = '';
            }
        };
        
        const navRight = bottomNav.createDiv('nav-right');
        const nextBtn = navRight.createEl('button', { cls: 'exam-btn exam-btn-secondary' });
        nextBtn.innerHTML = 'Next <span class="btn-icon">‚Üí</span>';
        nextBtn.onclick = () => this.goToNext();
        
        // Submit footer
        const submitFooter = contentEl.createDiv('exam-submit-footer');
        const submitBtn = submitFooter.createEl('button', { cls: 'exam-btn exam-btn-primary exam-btn-large' });
        submitBtn.innerHTML = '<span class="btn-icon">‚úì</span> Submit Exam';
        submitBtn.onclick = () => this.submitExam();
        
        // Render first question
        this.renderQuestion();
    }
    
    updateSidebarStatus() {
        const answered = this.questions.filter(q => {
            const answer = q.userAnswer;
            return answer !== undefined && (Array.isArray(answer) ? answer.length > 0 : answer !== '');
        }).length;
        const remaining = this.questions.length - answered;
        
        const answeredEl = this.contentEl.querySelector('.status-answered-count .status-count');
        const remainingEl = this.contentEl.querySelector('.status-remaining-count .status-count');
        
        if (answeredEl) answeredEl.textContent = answered.toString();
        if (remainingEl) remainingEl.textContent = remaining.toString();
    }
    
    updateGridStatus() {
        if (!this.questionGrid) return;
        const items = this.questionGrid.querySelectorAll('.grid-item');
        items.forEach((item, idx) => {
            item.removeClass('answered', 'active', 'skipped');
            if (idx === this.currentIndex) {
                item.addClass('active');
            }
            const answer = this.questions[idx].userAnswer;
            if (answer !== undefined && (Array.isArray(answer) ? answer.length > 0 : answer !== '')) {
                item.addClass('answered');
            }
        });
    }
    
    renderQuestion() {
        if (!this.examContainer) return;
        
        this.examContainer.empty();
        const question = this.questions[this.currentIndex];
        
        // Update progress display
        const currentQuestionEl = this.contentEl.querySelector('.current-question');
        if (currentQuestionEl) {
            currentQuestionEl.textContent = (this.currentIndex + 1).toString();
        }
        
        // Update progress bar
        const progressFill = this.contentEl.querySelector('.exam-progress-fill');
        if (progressFill) {
            const percentage = ((this.currentIndex + 1) / this.questions.length) * 100;
            progressFill.style.width = `${percentage}%`;
        }
        
        // Update sidebar
        this.updateSidebarStatus();
        this.updateGridStatus();
        
        // Question card - wrapper for scrolling
        const cardWrapper = this.examContainer.createDiv('question-card-wrapper');
        const card = cardWrapper.createDiv('question-card');
        
        // Question header
        const questionHeader = card.createDiv('question-header');
        
        const questionNumber = questionHeader.createDiv('question-number');
        questionNumber.textContent = `Question ${this.currentIndex + 1}`;
        
        const badge = questionHeader.createDiv('question-type-badge');
        if (question.type === 'multiple') {
            badge.textContent = 'Multiple Choice';
            badge.addClass('badge-multiple');
        } else if (question.type === 'freetext') {
            badge.textContent = 'Free Text';
            badge.addClass('badge-freetext');
        } else {
            badge.textContent = 'Single Choice';
            badge.addClass('badge-single');
        }
        
        // Question body
        const questionBody = card.createDiv('question-body');
        
        // Question text
        const questionTextEl = questionBody.createDiv('question-text');
        questionTextEl.createEl('span', { cls: 'question-id', text: `Q${question.id}. ` });
        questionTextEl.createSpan({ text: question.text });
        
        // Instruction text
        if (question.type === 'multiple') {
            questionBody.createDiv({ cls: 'question-instruction', text: 'Select all answers that apply' });
        }
        
        // Image if present
        if (question.imageUrl) {
            const imageContainer = questionBody.createDiv('question-image-container');
            const img = imageContainer.createEl('img', { cls: 'question-image' });
            
            const imagePath = question.imageUrl;
            const file = this.app.metadataCache.getFirstLinkpathDest(imagePath, this.sourcePath);
            if (file) {
                img.src = this.app.vault.getResourcePath(file);
            } else {
                img.src = imagePath;
            }
            img.alt = 'Question image';
        }
        
        // Answer section
        const answerSection = questionBody.createDiv('answer-section');
        
        if (question.type === 'freetext') {
            const input = answerSection.createEl('textarea', {
                cls: 'freetext-input',
                attr: { placeholder: 'Type your answer here...' }
            });
            input.value = question.userAnswer || '';
            input.oninput = () => {
                question.userAnswer = input.value;
                this.updateSidebarStatus();
                this.updateGridStatus();
            };
        } else {
            const optionsContainer = answerSection.createDiv('options-container');
            
            question.options.forEach(option => {
                const optionEl = optionsContainer.createDiv('option-item');
                
                const inputType = question.type === 'multiple' ? 'checkbox' : 'radio';
                const input = optionEl.createEl('input', {
                    type: inputType,
                    attr: {
                        name: `question-${question.id}`,
                        value: option.letter,
                        id: `option-${question.id}-${option.letter}`
                    }
                });
                
                if (question.userAnswer) {
                    const answers = Array.isArray(question.userAnswer) ? question.userAnswer : [question.userAnswer];
                    if (answers.includes(option.letter)) {
                        input.checked = true;
                        optionEl.addClass('selected');
                    }
                }
                
                const label = optionEl.createEl('label', {
                    attr: { for: `option-${question.id}-${option.letter}` }
                });
                
                const optionContent = label.createDiv('option-content');
                optionContent.createSpan({ cls: 'option-letter', text: option.letter });
                optionContent.createSpan({ cls: 'option-text', text: option.text });
                
                input.onchange = () => {
                    if (question.type === 'multiple') {
                        const checked = optionsContainer.querySelectorAll('input:checked');
                        question.userAnswer = Array.from(checked).map(c => c.value);
                    } else {
                        question.userAnswer = [option.letter];
                    }
                    
                    optionsContainer.querySelectorAll('.option-item').forEach(item => {
                        item.removeClass('selected');
                    });
                    optionsContainer.querySelectorAll('input:checked').forEach(checked => {
                        const parent = checked.closest('.option-item');
                        if (parent) parent.addClass('selected');
                    });
                    
                    this.updateSidebarStatus();
                    this.updateGridStatus();
                };
            });
        }
    }
    
    goToPrevious() {
        if (this.currentIndex > 0) {
            this.currentIndex--;
            this.renderQuestion();
        }
    }
    
    goToNext() {
        if (this.currentIndex < this.questions.length - 1) {
            this.currentIndex++;
            this.renderQuestion();
        }
    }
    
    goToQuestion(index) {
        this.currentIndex = index;
        this.renderQuestion();
    }
    
    submitExam() {
        const unanswered = this.questions.filter(q => 
            !q.userAnswer || 
            (Array.isArray(q.userAnswer) && q.userAnswer.length === 0) ||
            q.userAnswer === ''
        ).length;
        
        if (unanswered > 0) {
            const confirmSubmit = confirm(`You have ${unanswered} unanswered question(s). Are you sure you want to submit?`);
            if (!confirmSubmit) return;
        }
        
        const timeTaken = Math.floor((Date.now() - this.startTime) / 1000);
        
        let correct = 0;
        let wrong = 0;
        let skipped = 0;
        
        this.questions.forEach(q => {
            if (!q.userAnswer || 
                (Array.isArray(q.userAnswer) && q.userAnswer.length === 0) ||
                q.userAnswer === '') {
                skipped++;
                return;
            }
            
            if (q.type === 'freetext') {
                const userAnswerLower = q.userAnswer.toLowerCase().trim();
                const correctAnswerLower = q.correctAnswers[0].toLowerCase().trim();
                if (userAnswerLower === correctAnswerLower) {
                    correct++;
                } else {
                    wrong++;
                }
            } else {
                const userAnswers = Array.isArray(q.userAnswer) ? q.userAnswer : [q.userAnswer];
                const sortedUser = [...userAnswers].sort().join(',');
                const sortedCorrect = [...q.correctAnswers].sort().join(',');
                
                if (sortedUser === sortedCorrect) {
                    correct++;
                } else {
                    wrong++;
                }
            }
        });
        
        const result = {
            totalQuestions: this.questions.length,
            correctAnswers: correct,
            wrongAnswers: wrong,
            skipped,
            percentage: Math.round((correct / this.questions.length) * 100),
            timeTaken,
            questions: this.questions
        };
        
        this.close();
        new ResultsModal(this.app, result, this.sourcePath, this.sourceFileName).open();
    }
    
    onClose() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
        }
        this.contentEl.empty();
    }
}

// ============================================================================
// FULL REVIEW MODAL - Dedicated large review screen
// ============================================================================

class FullReviewModal extends obsidian.Modal {
    constructor(app, result, sourcePath) {
        super(app);
        this.result = result;
        this.sourcePath = sourcePath;
        this.currentFilter = 'all';
        this.currentQuestionIndex = 0;
    }
    
    onOpen() {
        const { contentEl, modalEl } = this;
        
        modalEl.addClass('full-review-modal-container');
        
        contentEl.empty();
        contentEl.addClass('full-review-modal');
        
        // Header
        const header = contentEl.createDiv('review-modal-header');
        header.createEl('h2', { text: 'Detailed Review' });
        
        const headerStats = header.createDiv('header-stats');
        headerStats.innerHTML = `
            <span class="header-stat correct">‚úì ${this.result.correctAnswers} Correct</span>
            <span class="header-stat wrong">‚úó ${this.result.wrongAnswers} Wrong</span>
            <span class="header-stat skipped">‚óã ${this.result.skipped} Skipped</span>
        `;
        
        const closeBtn = header.createEl('button', { cls: 'review-close-btn', text: '‚úï' });
        closeBtn.onclick = () => this.close();
        
        // Main layout
        const mainLayout = contentEl.createDiv('review-main-layout');
        
        // Sidebar with question list
        const sidebar = mainLayout.createDiv('review-sidebar');
        
        // Filters
        const filterContainer = sidebar.createDiv('review-filter-container');
        const filters = [
            { label: 'All', filter: 'all', count: this.result.totalQuestions },
            { label: 'Correct', filter: 'correct', count: this.result.correctAnswers },
            { label: 'Wrong', filter: 'wrong', count: this.result.wrongAnswers },
            { label: 'Skipped', filter: 'skipped', count: this.result.skipped }
        ];
        
        filters.forEach(f => {
            const btn = filterContainer.createEl('button', { cls: `sidebar-filter-btn ${f.filter === 'all' ? 'active' : ''}` });
            btn.innerHTML = `${f.label} <span class="filter-count">${f.count}</span>`;
            btn.setAttribute('data-filter', f.filter);
            btn.onclick = () => {
                filterContainer.querySelectorAll('.sidebar-filter-btn').forEach(b => b.removeClass('active'));
                btn.addClass('active');
                this.currentFilter = f.filter;
                this.renderQuestionList();
                this.currentQuestionIndex = 0;
                this.renderCurrentQuestion();
            };
        });
        
        // Question list
        const questionList = sidebar.createDiv('review-question-list');
        this.questionListEl = questionList;
        
        // Question detail area
        const detailArea = mainLayout.createDiv('review-detail-area');
        this.detailArea = detailArea;
        
        // Navigation bar
        const navBar = contentEl.createDiv('review-nav-bar');
        
        const prevBtn = navBar.createEl('button', { cls: 'exam-btn exam-btn-secondary' });
        prevBtn.innerHTML = '‚Üê Previous';
        prevBtn.onclick = () => this.goToPrevious();
        
        const navInfo = navBar.createDiv('nav-info');
        this.navInfoEl = navInfo;
        
        const nextBtn = navBar.createEl('button', { cls: 'exam-btn exam-btn-secondary' });
        nextBtn.innerHTML = 'Next ‚Üí';
        nextBtn.onclick = () => this.goToNext();
        
        // Render initial content
        this.renderQuestionList();
        this.renderCurrentQuestion();
    }
    
    getFilteredQuestions() {
        return this.result.questions.filter((q, idx) => {
            if (this.currentFilter === 'all') return true;
            const status = this.getQuestionStatus(q);
            return status === this.currentFilter;
        }).map((q, filteredIdx) => {
            const originalIdx = this.result.questions.indexOf(q);
            return { question: q, originalIndex: originalIdx, filteredIndex: filteredIdx };
        });
    }
    
    getQuestionStatus(q) {
        const wasSkipped = !q.userAnswer || 
            (Array.isArray(q.userAnswer) && q.userAnswer.length === 0) ||
            q.userAnswer === '';
        if (wasSkipped) return 'skipped';
        return this.checkAnswer(q) ? 'correct' : 'wrong';
    }
    
    renderQuestionList() {
        if (!this.questionListEl) return;
        this.questionListEl.empty();
        
        const filtered = this.getFilteredQuestions();
        
        filtered.forEach((item, idx) => {
            const q = item.question;
            const status = this.getQuestionStatus(q);
            
            const listItem = this.questionListEl.createDiv('question-list-item');
            listItem.setAttribute('data-index', idx.toString());
            listItem.addClass(status);
            
            if (idx === this.currentQuestionIndex) {
                listItem.addClass('active');
            }
            
            const statusIcon = listItem.createSpan({ cls: 'list-status-icon' });
            statusIcon.textContent = status === 'correct' ? '‚úì' : (status === 'wrong' ? '‚úó' : '‚óã');
            
            const questionInfo = listItem.createDiv('list-question-info');
            questionInfo.createDiv({ cls: 'list-question-num', text: `Q${q.id}` });
            questionInfo.createDiv({ cls: 'list-question-preview', text: q.text.substring(0, 50) + (q.text.length > 50 ? '...' : '') });
            
            listItem.onclick = () => {
                this.currentQuestionIndex = idx;
                this.renderQuestionList();
                this.renderCurrentQuestion();
            };
        });
    }
    
    renderCurrentQuestion() {
        if (!this.detailArea) return;
        this.detailArea.empty();
        
        const filtered = this.getFilteredQuestions();
        
        if (filtered.length === 0) {
            this.detailArea.createDiv({ cls: 'no-questions-message', text: 'No questions match this filter.' });
            if (this.navInfoEl) {
                this.navInfoEl.textContent = '0 of 0';
            }
            return;
        }
        
        if (this.currentQuestionIndex >= filtered.length) {
            this.currentQuestionIndex = filtered.length - 1;
        }
        
        const item = filtered[this.currentQuestionIndex];
        const q = item.question;
        const status = this.getQuestionStatus(q);
        
        // Update nav info
        if (this.navInfoEl) {
            this.navInfoEl.textContent = `${this.currentQuestionIndex + 1} of ${filtered.length}`;
        }
        
        // Question card
        const card = this.detailArea.createDiv('review-question-card');
        card.addClass(status);
        
        // Status banner
        const statusBanner = card.createDiv('status-banner');
        statusBanner.addClass(status);
        statusBanner.textContent = status === 'correct' ? '‚úì CORRECT' : (status === 'wrong' ? '‚úó INCORRECT' : '‚óã SKIPPED');
        
        // Question content
        const content = card.createDiv('review-question-content');
        
        // Question text
        const questionText = content.createDiv('review-full-question-text');
        questionText.createEl('strong', { text: `Q${q.id}. ` });
        questionText.createSpan({ text: q.text });
        
        // Image
        if (q.imageUrl) {
            const imageContainer = content.createDiv('review-full-image-container');
            const img = imageContainer.createEl('img', { cls: 'review-full-image' });
            const file = this.app.metadataCache.getFirstLinkpathDest(q.imageUrl, this.sourcePath);
            if (file) {
                img.src = this.app.vault.getResourcePath(file);
            } else {
                img.src = q.imageUrl;
            }
        }
        
        // Options
        if (q.options.length > 0) {
            const optionsContainer = content.createDiv('review-full-options');
            
            q.options.forEach(opt => {
                const optEl = optionsContainer.createDiv('review-full-option');
                const isUserAnswer = Array.isArray(q.userAnswer) ? 
                    q.userAnswer.includes(opt.letter) : 
                    q.userAnswer === opt.letter;
                const isCorrectAnswer = q.correctAnswers.includes(opt.letter);
                
                if (isCorrectAnswer) optEl.addClass('correct-answer');
                if (isUserAnswer && !isCorrectAnswer) optEl.addClass('wrong-answer');
                if (isUserAnswer && isCorrectAnswer) optEl.addClass('user-correct');
                
                const optContent = optEl.createDiv('option-main');
                optContent.createSpan({ cls: 'option-letter', text: opt.letter });
                optContent.createSpan({ cls: 'option-text', text: opt.text });
                
                const markers = optEl.createDiv('option-markers');
                if (isCorrectAnswer) {
                    markers.createSpan({ cls: 'marker correct-marker', text: '‚úì Correct Answer' });
                }
                if (isUserAnswer && !isCorrectAnswer) {
                    markers.createSpan({ cls: 'marker wrong-marker', text: '‚úó Your Answer' });
                }
                if (isUserAnswer && isCorrectAnswer) {
                    markers.createSpan({ cls: 'marker correct-marker', text: '‚úì Your Answer' });
                }
            });
        } else {
            // Free text
            const freetextContainer = content.createDiv('review-freetext-container');
            
            const yourAnswer = freetextContainer.createDiv('freetext-row');
            yourAnswer.createSpan({ cls: 'freetext-label', text: 'Your Answer:' });
            yourAnswer.createSpan({ cls: 'freetext-value user', text: q.userAnswer || '(Not answered)' });
            
            const correctAnswer = freetextContainer.createDiv('freetext-row');
            correctAnswer.createSpan({ cls: 'freetext-label', text: 'Correct Answer:' });
            correctAnswer.createSpan({ cls: 'freetext-value correct', text: q.correctAnswers[0] });
        }
    }
    
    goToPrevious() {
        const filtered = this.getFilteredQuestions();
        if (this.currentQuestionIndex > 0) {
            this.currentQuestionIndex--;
            this.renderQuestionList();
            this.renderCurrentQuestion();
        }
    }
    
    goToNext() {
        const filtered = this.getFilteredQuestions();
        if (this.currentQuestionIndex < filtered.length - 1) {
            this.currentQuestionIndex++;
            this.renderQuestionList();
            this.renderCurrentQuestion();
        }
    }
    
    checkAnswer(q) {
        if (!q.userAnswer || 
            (Array.isArray(q.userAnswer) && q.userAnswer.length === 0) ||
            q.userAnswer === '') {
            return false;
        }
        
        if (q.type === 'freetext') {
            const userAnswerLower = q.userAnswer.toLowerCase().trim();
            const correctAnswerLower = q.correctAnswers[0].toLowerCase().trim();
            return userAnswerLower === correctAnswerLower;
        } else {
            const userAnswers = Array.isArray(q.userAnswer) ? q.userAnswer : [q.userAnswer];
            const sortedUser = [...userAnswers].sort().join(',');
            const sortedCorrect = [...q.correctAnswers].sort().join(',');
            return sortedUser === sortedCorrect;
        }
    }
    
    onClose() {
        this.contentEl.empty();
    }
}

// ============================================================================
// RESULTS MODAL - Score summary with button to open full review
// ============================================================================

class ResultsModal extends obsidian.Modal {
    constructor(app, result, sourcePath, sourceFileName) {
        super(app);
        this.result = result;
        this.sourcePath = sourcePath;
        this.sourceFileName = sourceFileName;
    }
    
    onOpen() {
        const { contentEl, modalEl } = this;
        
        modalEl.addClass('exam-results-modal-container');
        
        contentEl.empty();
        contentEl.addClass('exam-results-modal');
        
        // Header
        const header = contentEl.createDiv('results-header');
        header.createEl('h2', { text: 'Exam Complete!' });
        header.createDiv({ cls: 'results-subtitle', text: this.sourceFileName.replace(/\.md$/, '') });
        
        // Score section
        const scoreSection = contentEl.createDiv('score-section');
        
        const scoreCircle = scoreSection.createDiv('score-circle');
        const percentage = this.result.percentage;
        scoreCircle.addClass(percentage >= 70 ? 'pass' : 'fail');
        scoreCircle.createSpan({ cls: 'score-value', text: `${percentage}%` });
        scoreCircle.createSpan({ cls: 'score-label', text: percentage >= 70 ? 'PASSED' : 'FAILED' });
        
        const statsGrid = scoreSection.createDiv('stats-grid');
        
        const statItems = [
            { label: 'Total', value: this.result.totalQuestions, cls: 'stat-total', icon: 'üìù' },
            { label: 'Correct', value: this.result.correctAnswers, cls: 'stat-correct', icon: '‚úì' },
            { label: 'Wrong', value: this.result.wrongAnswers, cls: 'stat-wrong', icon: '‚úó' },
            { label: 'Skipped', value: this.result.skipped, cls: 'stat-skipped', icon: '‚óã' }
        ];
        
        statItems.forEach(item => {
            const stat = statsGrid.createDiv(`stat-card ${item.cls}`);
            stat.createDiv({ cls: 'stat-icon', text: item.icon });
            stat.createDiv({ cls: 'stat-value', text: item.value.toString() });
            stat.createDiv({ cls: 'stat-label', text: item.label });
        });
        
        // Time taken
        const minutes = Math.floor(this.result.timeTaken / 60);
        const seconds = this.result.timeTaken % 60;
        scoreSection.createDiv({ cls: 'time-taken', text: `‚è± Time: ${minutes}m ${seconds}s` });
        
        // Actions
        const actionsSection = contentEl.createDiv('results-actions');
        
        // Review button - opens full review modal
        const reviewBtn = actionsSection.createEl('button', { cls: 'exam-btn exam-btn-primary exam-btn-large' });
        reviewBtn.innerHTML = '<span class="btn-icon">üìã</span> Review All Answers';
        reviewBtn.onclick = () => {
            new FullReviewModal(this.app, this.result, this.sourcePath).open();
        };
        
        // Save mistakes button
        const mistakeQuestions = this.result.questions.filter(q => !this.checkAnswer(q));
        if (mistakeQuestions.length > 0) {
            const saveBtn = actionsSection.createEl('button', { cls: 'exam-btn exam-btn-warning exam-btn-large' });
            saveBtn.innerHTML = `<span class="btn-icon">üìù</span> Save ${mistakeQuestions.length} Mistake(s) to Note`;
            saveBtn.onclick = () => this.saveMistakesToNote(mistakeQuestions);
        }
        
        // Close button
        const closeBtn = actionsSection.createEl('button', { cls: 'exam-btn exam-btn-secondary exam-btn-large' });
        closeBtn.textContent = 'Close';
        closeBtn.onclick = () => this.close();
    }
    
    async saveMistakesToNote(mistakeQuestions) {
        const date = new Date();
        const dateStr = date.toISOString().split('T')[0];
        const timeStr = date.toTimeString().split(' ')[0].replace(/:/g, '-');
        
        const baseName = this.sourceFileName.replace(/\.md$/, '');
        const fileName = `${baseName} - Mistakes ${dateStr} ${timeStr}.md`;
        
        let content = `# Exam Mistakes Review\n\n`;
        content += `## Summary\n\n`;
        content += `| Property | Value |\n`;
        content += `|----------|-------|\n`;
        content += `| **Source Exam** | ${this.sourceFileName} |\n`;
        content += `| **Date** | ${date.toLocaleString()} |\n`;
        content += `| **Score** | ${this.result.percentage}% |\n`;
        content += `| **Correct** | ${this.result.correctAnswers}/${this.result.totalQuestions} |\n`;
        content += `| **Wrong** | ${this.result.wrongAnswers} |\n`;
        content += `| **Skipped** | ${this.result.skipped} |\n`;
        content += `| **Mistakes in this file** | ${mistakeQuestions.length} |\n\n`;
        content += `---\n\n`;
        content += `## Questions to Review\n\n`;
        
        mistakeQuestions.forEach((q, idx) => {
            content += `### ${idx + 1}. Question ${q.id}\n\n`;
            content += formatQuestionForExport(q, true);
            content += `\n---\n\n`;
        });
        
        try {
            const sourceFile = this.app.vault.getAbstractFileByPath(this.sourcePath);
            let folderPath = '';
            if (sourceFile && sourceFile.parent) {
                folderPath = sourceFile.parent.path;
            }
            
            const filePath = folderPath ? `${folderPath}/${fileName}` : fileName;
            
            await this.app.vault.create(filePath, content);
            new obsidian.Notice(`‚úì Saved ${mistakeQuestions.length} mistake(s) to "${fileName}"`);
        } catch (error) {
            console.error('Error saving mistakes:', error);
            new obsidian.Notice(`Error saving mistakes: ${error.message}`);
        }
    }
    
    checkAnswer(q) {
        if (!q.userAnswer || 
            (Array.isArray(q.userAnswer) && q.userAnswer.length === 0) ||
            q.userAnswer === '') {
            return false;
        }
        
        if (q.type === 'freetext') {
            const userAnswerLower = q.userAnswer.toLowerCase().trim();
            const correctAnswerLower = q.correctAnswers[0].toLowerCase().trim();
            return userAnswerLower === correctAnswerLower;
        } else {
            const userAnswers = Array.isArray(q.userAnswer) ? q.userAnswer : [q.userAnswer];
            const sortedUser = [...userAnswers].sort().join(',');
            const sortedCorrect = [...q.correctAnswers].sort().join(',');
            return sortedUser === sortedCorrect;
        }
    }
    
    onClose() {
        this.contentEl.empty();
    }
}

class ExamCreatorSettingTab extends obsidian.PluginSettingTab {
    constructor(app, plugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display() {
        const { containerEl } = this;
        containerEl.empty();

        containerEl.createEl('h2', { text: 'Exam Creator Settings' });

        new obsidian.Setting(containerEl)
            .setName('Shuffle Questions')
            .setDesc('Randomize the order of questions in each exam')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.shuffleQuestions)
                .onChange(async (value) => {
                    this.plugin.settings.shuffleQuestions = value;
                    await this.plugin.saveSettings();
                }));

        new obsidian.Setting(containerEl)
            .setName('Shuffle Answers')
            .setDesc('Randomize the order of answer options for each question')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.shuffleAnswers)
                .onChange(async (value) => {
                    this.plugin.settings.shuffleAnswers = value;
                    await this.plugin.saveSettings();
                }));

        new obsidian.Setting(containerEl)
            .setName('Show Timer')
            .setDesc('Display a timer during the exam')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.showTimer)
                .onChange(async (value) => {
                    this.plugin.settings.showTimer = value;
                    await this.plugin.saveSettings();
                }));

        new obsidian.Setting(containerEl)
            .setName('Default Time Limit')
            .setDesc('Default time limit in minutes (0 = no limit)')
            .addText(text => text
                .setValue(this.plugin.settings.defaultTimeLimit.toString())
                .onChange(async (value) => {
                    const num = parseInt(value) || 0;
                    this.plugin.settings.defaultTimeLimit = num;
                    await this.plugin.saveSettings();
                }));
    }
}

class ExamCreatorPlugin extends obsidian.Plugin {
    constructor() {
        super(...arguments);
        this.settings = DEFAULT_SETTINGS;
    }
    
    async onload() {
        await this.loadSettings();

        this.addRibbonIcon('check-square', 'Start Exam', () => {
            this.startExamFromCurrentFile();
        });

        this.addCommand({
            id: 'start-exam',
            name: 'Start Exam from Current Note',
            editorCallback: (editor, view) => {
                this.startExamFromCurrentFile();
            }
        });

        this.addCommand({
            id: 'preview-questions',
            name: 'Preview Questions in Current Note',
            editorCallback: (editor, view) => {
                this.previewQuestions();
            }
        });

        this.addSettingTab(new ExamCreatorSettingTab(this.app, this));
    }

    onunload() {
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }

    async startExamFromCurrentFile() {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
            new obsidian.Notice('No active file. Please open a note with exam questions.');
            return;
        }

        const content = await this.app.vault.read(activeFile);
        const questions = parseQuestions(content);

        if (questions.length === 0) {
            new obsidian.Notice('No questions found in this note. Make sure your questions follow the format:\n\nQ001. Question text\nA. Option\nB. Option\nAnswer: A');
            return;
        }

        new obsidian.Notice(`Found ${questions.length} questions. Starting exam...`);
        new ExamModal(this.app, questions, this.settings, activeFile.path, activeFile.name).open();
    }

    async previewQuestions() {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
            new obsidian.Notice('No active file.');
            return;
        }

        const content = await this.app.vault.read(activeFile);
        const questions = parseQuestions(content);

        if (questions.length === 0) {
            new obsidian.Notice('No questions found.');
            return;
        }

        const modal = new obsidian.Modal(this.app);
        modal.contentEl.addClass('exam-preview-modal');
        modal.contentEl.createEl('h2', { text: `Preview: ${questions.length} Questions Found` });
        
        const list = modal.contentEl.createDiv('preview-list');
        questions.forEach((q, idx) => {
            const item = list.createDiv('preview-item');
            item.createDiv({ cls: 'preview-question', text: `Q${q.id}. ${q.text}` });
            item.createDiv({ cls: 'preview-type', text: `Type: ${q.type} | Options: ${q.options.length} | Answer: ${q.correctAnswers.join(', ')}` });
            if (q.imageUrl) {
                item.createDiv({ cls: 'preview-image-info', text: `üì∑ Image: ${q.imageUrl}` });
            }
        });
        
        modal.open();
    }
}

module.exports = ExamCreatorPlugin;
