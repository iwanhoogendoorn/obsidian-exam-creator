/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ExamCreatorPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  shuffleQuestions: false,
  shuffleAnswers: false,
  showTimer: true,
  defaultTimeLimit: 0,
  showImmediateFeedback: false
};
var ConfirmModal = class extends import_obsidian.Modal {
  constructor(app, message, onConfirm) {
    super(app);
    this.message = message;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("exam-confirm-modal");
    contentEl.createEl("p", { text: this.message });
    const buttonContainer = contentEl.createDiv("confirm-buttons");
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel", cls: "exam-btn exam-btn-secondary" });
    cancelBtn.onclick = () => this.close();
    const confirmBtn = buttonContainer.createEl("button", { text: "Submit", cls: "exam-btn exam-btn-primary" });
    confirmBtn.onclick = () => {
      this.close();
      this.onConfirm();
    };
  }
  onClose() {
    this.contentEl.empty();
  }
};
function parseQuestions(content) {
  const questions = [];
  const questionBlocks = content.split(/(?=Q\d+\.)/);
  for (const block of questionBlocks) {
    const trimmed = block.trim();
    if (!trimmed || !trimmed.match(/^Q\d+\./))
      continue;
    const question = parseQuestionBlock(trimmed);
    if (question) {
      questions.push(question);
    }
  }
  return questions;
}
function parseQuestionBlock(block) {
  const lines = block.split("\n").map((l) => l.trim()).filter((l) => l);
  if (lines.length === 0)
    return null;
  const firstLine = lines[0];
  const idMatch = firstLine.match(/^Q(\d+)\.\s*(.*)/);
  if (!idMatch)
    return null;
  const id = idMatch[1];
  let questionText = idMatch[2];
  const options = [];
  let correctAnswers = [];
  let imageUrl;
  let answerLineIndex = -1;
  const imagePattern = /!\[\[([^\]]+)\]\]|!\[([^\]]*)\]\(([^)]+)\)/;
  let questionTextLines = [questionText];
  let i = 1;
  while (i < lines.length) {
    const line = lines[i];
    const imgMatch = line.match(imagePattern);
    if (imgMatch) {
      imageUrl = imgMatch[1] || imgMatch[3];
      i++;
      continue;
    }
    if (line.match(/^[A-Z]\.\s+/)) {
      break;
    }
    if (line.match(/^Answer:/i)) {
      break;
    }
    const textImgMatch2 = line.match(imagePattern);
    if (textImgMatch2) {
      imageUrl = textImgMatch2[1] || textImgMatch2[3];
    } else if (line.toLowerCase().includes("with image support")) {
    } else {
      questionTextLines.push(line);
    }
    i++;
  }
  questionText = questionTextLines.join(" ").trim();
  const textImgMatch = questionText.match(imagePattern);
  if (textImgMatch && !imageUrl) {
    imageUrl = textImgMatch[1] || textImgMatch[3];
    questionText = questionText.replace(imagePattern, "").trim();
  }
  while (i < lines.length) {
    const line = lines[i];
    if (line.match(/^Answer:/i)) {
      answerLineIndex = i;
      break;
    }
    const optionMatch = line.match(/^([A-Z])\.\s+(.*)/);
    if (optionMatch) {
      options.push({
        letter: optionMatch[1],
        text: optionMatch[2]
      });
    }
    i++;
  }
  if (answerLineIndex >= 0) {
    const answerLine = lines[answerLineIndex];
    const answerMatch = answerLine.match(/^Answer:\s*(.*)/i);
    if (answerMatch) {
      const answerText = answerMatch[1].trim();
      if (answerText.match(/^[A-Z](\s*,\s*[A-Z])*$/)) {
        correctAnswers = answerText.split(/\s*,\s*/).map((a) => a.trim().toUpperCase());
      } else if (answerText.match(/^[A-Z]$/)) {
        correctAnswers = [answerText.toUpperCase()];
      } else {
        correctAnswers = [answerText];
      }
    }
  }
  let type;
  if (options.length === 0) {
    type = "freetext";
  } else if (correctAnswers.length > 1 && correctAnswers.every((a) => a.match(/^[A-Z]$/))) {
    type = "multiple";
  } else {
    type = "single";
  }
  return {
    id,
    text: questionText,
    imageUrl,
    options,
    correctAnswers,
    type
  };
}
function shuffleArray(array) {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
}
var ExamModal = class extends import_obsidian.Modal {
  constructor(app, questions, settings, sourcePath) {
    super(app);
    this.currentIndex = 0;
    this.timerInterval = null;
    this.examContainer = null;
    this.settings = settings;
    this.sourcePath = sourcePath;
    this.questions = settings.shuffleQuestions ? shuffleArray(questions) : [...questions];
    if (settings.shuffleAnswers) {
      this.questions = this.questions.map((q) => ({
        ...q,
        options: shuffleArray(q.options)
      }));
    }
    this.startTime = Date.now();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("exam-creator-modal");
    const header = contentEl.createDiv("exam-header");
    const progressInfo = header.createDiv("exam-progress");
    progressInfo.createSpan({ text: `Question ` });
    progressInfo.createSpan({ cls: "current-question", text: "1" });
    progressInfo.createSpan({ text: ` of ${this.questions.length}` });
    if (this.settings.showTimer) {
      const timerEl = header.createDiv("exam-timer");
      timerEl.createSpan({ cls: "timer-icon", text: "\u23F1\uFE0F" });
      timerEl.createSpan({ cls: "timer-value", text: "00:00" });
      this.timerInterval = window.setInterval(() => {
        const elapsed = Math.floor((Date.now() - this.startTime) / 1e3);
        const minutes = Math.floor(elapsed / 60).toString().padStart(2, "0");
        const seconds = (elapsed % 60).toString().padStart(2, "0");
        const timerValue = timerEl.querySelector(".timer-value");
        if (timerValue) {
          timerValue.textContent = `${minutes}:${seconds}`;
        }
      }, 1e3);
    }
    const progressBar = contentEl.createDiv("exam-progress-bar");
    progressBar.createDiv("exam-progress-fill");
    this.examContainer = contentEl.createDiv("exam-container");
    const nav = contentEl.createDiv("exam-navigation");
    const prevBtn = nav.createEl("button", { text: "\u2190 Previous", cls: "exam-btn exam-btn-secondary" });
    prevBtn.onclick = () => this.goToPrevious();
    const questionNav = nav.createDiv("question-nav");
    this.questions.forEach((_, idx) => {
      const btn = questionNav.createEl("button", {
        text: (idx + 1).toString(),
        cls: "question-nav-btn"
      });
      btn.onclick = () => this.goToQuestion(idx);
    });
    const nextBtn = nav.createEl("button", { text: "Next \u2192", cls: "exam-btn exam-btn-secondary" });
    nextBtn.onclick = () => this.goToNext();
    const submitContainer = contentEl.createDiv("exam-submit-container");
    const submitBtn = submitContainer.createEl("button", { text: "Submit exam", cls: "exam-btn exam-btn-primary" });
    submitBtn.onclick = () => this.submitExam();
    this.renderQuestion();
  }
  renderQuestion() {
    if (!this.examContainer)
      return;
    this.examContainer.empty();
    const question = this.questions[this.currentIndex];
    const currentQuestionEl = this.contentEl.querySelector(".current-question");
    if (currentQuestionEl) {
      currentQuestionEl.textContent = (this.currentIndex + 1).toString();
    }
    const progressFill = this.contentEl.querySelector(".exam-progress-fill");
    if (progressFill) {
      const percentage = (this.currentIndex + 1) / this.questions.length * 100;
      progressFill.style.width = `${percentage}%`;
    }
    const navBtns = this.contentEl.querySelectorAll(".question-nav-btn");
    navBtns.forEach((btn, idx) => {
      btn.removeClass("active", "answered");
      if (idx === this.currentIndex) {
        btn.addClass("active");
      }
      if (this.questions[idx].userAnswer !== void 0) {
        btn.addClass("answered");
      }
    });
    const card = this.examContainer.createDiv("question-card");
    const badge = card.createDiv("question-type-badge");
    if (question.type === "multiple") {
      badge.textContent = "Multiple choice (select all that apply)";
      badge.addClass("badge-multiple");
    } else if (question.type === "freetext") {
      badge.textContent = "Free text";
      badge.addClass("badge-freetext");
    } else {
      badge.textContent = "Single choice";
      badge.addClass("badge-single");
    }
    const questionTextEl = card.createDiv("question-text");
    questionTextEl.createEl("strong", { text: `Q${question.id}. ` });
    questionTextEl.createSpan({ text: question.text });
    if (question.imageUrl) {
      const imageContainer = card.createDiv("question-image-container");
      const img = imageContainer.createEl("img", { cls: "question-image" });
      const imagePath = question.imageUrl;
      const file = this.app.metadataCache.getFirstLinkpathDest(imagePath, this.sourcePath);
      if (file) {
        img.src = this.app.vault.getResourcePath(file);
      } else {
        img.src = imagePath;
      }
      img.alt = "Question image";
    }
    const answerSection = card.createDiv("answer-section");
    if (question.type === "freetext") {
      const input = answerSection.createEl("textarea", {
        cls: "freetext-input",
        attr: { placeholder: "Type your answer here..." }
      });
      input.value = question.userAnswer || "";
      input.oninput = () => {
        question.userAnswer = input.value;
        this.updateNavButtons();
      };
    } else {
      const optionsContainer = answerSection.createDiv("options-container");
      question.options.forEach((option) => {
        const optionEl = optionsContainer.createDiv("option-item");
        const inputType = question.type === "multiple" ? "checkbox" : "radio";
        const input = optionEl.createEl("input", {
          type: inputType,
          attr: {
            name: `question-${question.id}`,
            value: option.letter,
            id: `option-${question.id}-${option.letter}`
          }
        });
        if (question.userAnswer) {
          const answers = Array.isArray(question.userAnswer) ? question.userAnswer : [question.userAnswer];
          if (answers.includes(option.letter)) {
            input.checked = true;
            optionEl.addClass("selected");
          }
        }
        const label = optionEl.createEl("label", {
          attr: { for: `option-${question.id}-${option.letter}` }
        });
        label.createSpan({ cls: "option-letter", text: option.letter });
        label.createSpan({ cls: "option-text", text: option.text });
        input.onchange = () => {
          if (question.type === "multiple") {
            const checked = optionsContainer.querySelectorAll("input:checked");
            question.userAnswer = Array.from(checked).map((c) => c.value);
          } else {
            question.userAnswer = [option.letter];
          }
          optionsContainer.querySelectorAll(".option-item").forEach((item) => {
            item.removeClass("selected");
          });
          optionsContainer.querySelectorAll("input:checked").forEach((checked) => {
            var _a;
            (_a = checked.closest(".option-item")) == null ? void 0 : _a.addClass("selected");
          });
          this.updateNavButtons();
        };
      });
    }
  }
  updateNavButtons() {
    const navBtns = this.contentEl.querySelectorAll(".question-nav-btn");
    navBtns.forEach((btn, idx) => {
      btn.removeClass("answered");
      const answer = this.questions[idx].userAnswer;
      if (answer !== void 0 && (Array.isArray(answer) ? answer.length > 0 : answer !== "")) {
        btn.addClass("answered");
      }
    });
  }
  goToPrevious() {
    if (this.currentIndex > 0) {
      this.currentIndex--;
      this.renderQuestion();
    }
  }
  goToNext() {
    if (this.currentIndex < this.questions.length - 1) {
      this.currentIndex++;
      this.renderQuestion();
    }
  }
  goToQuestion(index) {
    this.currentIndex = index;
    this.renderQuestion();
  }
  submitExam() {
    const unanswered = this.questions.filter(
      (q) => !q.userAnswer || Array.isArray(q.userAnswer) && q.userAnswer.length === 0 || q.userAnswer === ""
    ).length;
    if (unanswered > 0) {
      new ConfirmModal(
        this.app,
        `You have ${unanswered} unanswered question(s). Are you sure you want to submit?`,
        () => this.finalizeSubmission()
      ).open();
      return;
    }
    this.finalizeSubmission();
  }
  finalizeSubmission() {
    const timeTaken = Math.floor((Date.now() - this.startTime) / 1e3);
    let correct = 0;
    let wrong = 0;
    let skipped = 0;
    this.questions.forEach((q) => {
      if (!q.userAnswer || Array.isArray(q.userAnswer) && q.userAnswer.length === 0 || q.userAnswer === "") {
        skipped++;
        return;
      }
      if (q.type === "freetext") {
        const userAnswerLower = q.userAnswer.toLowerCase().trim();
        const correctAnswerLower = q.correctAnswers[0].toLowerCase().trim();
        if (userAnswerLower === correctAnswerLower) {
          correct++;
        } else {
          wrong++;
        }
      } else {
        const userAnswers = Array.isArray(q.userAnswer) ? q.userAnswer : [q.userAnswer];
        const sortedUser = [...userAnswers].sort().join(",");
        const sortedCorrect = [...q.correctAnswers].sort().join(",");
        if (sortedUser === sortedCorrect) {
          correct++;
        } else {
          wrong++;
        }
      }
    });
    const result = {
      totalQuestions: this.questions.length,
      correctAnswers: correct,
      wrongAnswers: wrong,
      skipped,
      percentage: Math.round(correct / this.questions.length * 100),
      timeTaken,
      questions: this.questions
    };
    this.close();
    new ResultsModal(this.app, result, this.sourcePath).open();
  }
  onClose() {
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
    }
    this.contentEl.empty();
  }
};
var ResultsModal = class extends import_obsidian.Modal {
  constructor(app, result, sourcePath) {
    super(app);
    this.result = result;
    this.sourcePath = sourcePath;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("exam-results-modal");
    const header = contentEl.createDiv("results-header");
    header.createEl("h2", { text: "Exam results" });
    const scoreCard = contentEl.createDiv("score-card");
    const scoreCircle = scoreCard.createDiv("score-circle");
    const percentage = this.result.percentage;
    scoreCircle.addClass(percentage >= 70 ? "pass" : "fail");
    scoreCircle.createSpan({ cls: "score-value", text: `${percentage}%` });
    scoreCircle.createSpan({ cls: "score-label", text: percentage >= 70 ? "PASSED" : "FAILED" });
    const stats = scoreCard.createDiv("score-stats");
    const statItems = [
      { label: "Total Questions", value: this.result.totalQuestions.toString(), cls: "stat-total" },
      { label: "Correct", value: this.result.correctAnswers.toString(), cls: "stat-correct" },
      { label: "Wrong", value: this.result.wrongAnswers.toString(), cls: "stat-wrong" },
      { label: "Skipped", value: this.result.skipped.toString(), cls: "stat-skipped" }
    ];
    statItems.forEach((item) => {
      const stat = stats.createDiv(`stat-item ${item.cls}`);
      stat.createDiv({ cls: "stat-value", text: item.value });
      stat.createDiv({ cls: "stat-label", text: item.label });
    });
    const minutes = Math.floor(this.result.timeTaken / 60);
    const seconds = this.result.timeTaken % 60;
    const timeText = `Time taken: ${minutes}m ${seconds}s`;
    scoreCard.createDiv({ cls: "time-taken", text: timeText });
    const reviewSection = contentEl.createDiv("review-section");
    reviewSection.createEl("h3", { text: "Review answers" });
    this.result.questions.forEach((q, idx) => {
      const isCorrect = this.checkAnswer(q);
      const wasSkipped = !q.userAnswer || Array.isArray(q.userAnswer) && q.userAnswer.length === 0 || q.userAnswer === "";
      const reviewItem = reviewSection.createDiv("review-item");
      reviewItem.addClass(wasSkipped ? "skipped" : isCorrect ? "correct" : "incorrect");
      const statusIcon = reviewItem.createDiv("status-icon");
      statusIcon.textContent = wasSkipped ? "\u25CB" : isCorrect ? "\u2713" : "\u2717";
      const content = reviewItem.createDiv("review-content");
      const questionHeader = content.createDiv("review-question-header");
      questionHeader.createSpan({ text: `Q${q.id}. ${q.text}` });
      if (q.imageUrl) {
        const imageContainer = content.createDiv("review-image-container");
        const img = imageContainer.createEl("img", { cls: "review-image" });
        const file = this.app.metadataCache.getFirstLinkpathDest(q.imageUrl, this.sourcePath);
        if (file) {
          img.src = this.app.vault.getResourcePath(file);
        } else {
          img.src = q.imageUrl;
        }
      }
      if (q.options.length > 0) {
        const optionsReview = content.createDiv("review-options");
        q.options.forEach((opt) => {
          const optEl = optionsReview.createDiv("review-option");
          const isUserAnswer = Array.isArray(q.userAnswer) ? q.userAnswer.includes(opt.letter) : q.userAnswer === opt.letter;
          const isCorrectAnswer = q.correctAnswers.includes(opt.letter);
          if (isCorrectAnswer) {
            optEl.addClass("correct-answer");
          }
          if (isUserAnswer && !isCorrectAnswer) {
            optEl.addClass("wrong-answer");
          }
          if (isUserAnswer && isCorrectAnswer) {
            optEl.addClass("user-correct");
          }
          optEl.createSpan({ cls: "option-letter", text: opt.letter });
          optEl.createSpan({ cls: "option-text", text: opt.text });
          if (isCorrectAnswer) {
            optEl.createSpan({ cls: "correct-marker", text: " \u2713" });
          }
          if (isUserAnswer && !isCorrectAnswer) {
            optEl.createSpan({ cls: "wrong-marker", text: " \u2717" });
          }
        });
      } else {
        const freetextReview = content.createDiv("review-freetext");
        const userAnswerText = typeof q.userAnswer === "string" ? q.userAnswer : "(not answered)";
        freetextReview.createDiv({ text: `Your answer: ${userAnswerText}` });
        freetextReview.createDiv({ text: `Correct answer: ${q.correctAnswers[0]}`, cls: "correct-answer-text" });
      }
    });
    const btnContainer = contentEl.createDiv("results-buttons");
    const closeBtn = btnContainer.createEl("button", { text: "Close", cls: "exam-btn exam-btn-primary" });
    closeBtn.onclick = () => this.close();
  }
  checkAnswer(q) {
    if (!q.userAnswer || Array.isArray(q.userAnswer) && q.userAnswer.length === 0 || q.userAnswer === "") {
      return false;
    }
    if (q.type === "freetext") {
      const userAnswerLower = q.userAnswer.toLowerCase().trim();
      const correctAnswerLower = q.correctAnswers[0].toLowerCase().trim();
      return userAnswerLower === correctAnswerLower;
    } else {
      const userAnswers = Array.isArray(q.userAnswer) ? q.userAnswer : [q.userAnswer];
      const sortedUser = [...userAnswers].sort().join(",");
      const sortedCorrect = [...q.correctAnswers].sort().join(",");
      return sortedUser === sortedCorrect;
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};
var ExamCreatorSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Exam creator settings").setHeading();
    new import_obsidian.Setting(containerEl).setName("Shuffle questions").setDesc("Randomize the order of questions in each exam").addToggle((toggle) => toggle.setValue(this.plugin.settings.shuffleQuestions).onChange(async (value) => {
      this.plugin.settings.shuffleQuestions = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Shuffle answers").setDesc("Randomize the order of answer options for each question").addToggle((toggle) => toggle.setValue(this.plugin.settings.shuffleAnswers).onChange(async (value) => {
      this.plugin.settings.shuffleAnswers = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show timer").setDesc("Display a timer during the exam").addToggle((toggle) => toggle.setValue(this.plugin.settings.showTimer).onChange(async (value) => {
      this.plugin.settings.showTimer = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default time limit").setDesc("Default time limit in minutes (0 = no limit)").addText((text) => text.setValue(this.plugin.settings.defaultTimeLimit.toString()).onChange(async (value) => {
      const num = parseInt(value) || 0;
      this.plugin.settings.defaultTimeLimit = num;
      await this.plugin.saveSettings();
    }));
  }
};
var ExamCreatorPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.settings = DEFAULT_SETTINGS;
  }
  async onload() {
    await this.loadSettings();
    this.addRibbonIcon("check-square", "Start exam", () => {
      void this.startExamFromCurrentFile();
    });
    this.addCommand({
      id: "start-exam",
      name: "Start exam from current note",
      editorCallback: () => {
        void this.startExamFromCurrentFile();
      }
    });
    this.addCommand({
      id: "preview-questions",
      name: "Preview questions in current note",
      editorCallback: () => {
        void this.previewQuestions();
      }
    });
    this.addSettingTab(new ExamCreatorSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async startExamFromCurrentFile() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file. Please open a note with exam questions.");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const questions = parseQuestions(content);
    if (questions.length === 0) {
      new import_obsidian.Notice("No questions found in this note. Make sure your questions follow the format:\n\nQ001. Question text\nA. Option\nB. Option\nAnswer: A");
      return;
    }
    new import_obsidian.Notice(`Found ${questions.length} questions. Starting exam...`);
    new ExamModal(this.app, questions, this.settings, activeFile.path).open();
  }
  async previewQuestions() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian.Notice("No active file.");
      return;
    }
    const content = await this.app.vault.read(activeFile);
    const questions = parseQuestions(content);
    if (questions.length === 0) {
      new import_obsidian.Notice("No questions found.");
      return;
    }
    const modal = new import_obsidian.Modal(this.app);
    modal.contentEl.addClass("exam-preview-modal");
    modal.contentEl.createEl("h2", { text: `Preview: ${questions.length} Questions Found` });
    const list = modal.contentEl.createDiv("preview-list");
    questions.forEach((q, idx) => {
      const item = list.createDiv("preview-item");
      item.createDiv({ cls: "preview-question", text: `Q${q.id}. ${q.text}` });
      item.createDiv({ cls: "preview-type", text: `Type: ${q.type} | Options: ${q.options.length} | Answer: ${q.correctAnswers.join(", ")}` });
      if (q.imageUrl) {
        item.createDiv({ cls: "preview-image-info", text: `\u{1F4F7} Image: ${q.imageUrl}` });
      }
    });
    modal.open();
  }
};
